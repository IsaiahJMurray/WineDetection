<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wine Classifier</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    :root{
      --bg:#0a0a0f;
      --card:rgba(15,15,21,.92);
      --card2:rgba(18,18,26,.88);
      --border:#1a1a25;
      --border2:#252530;
      --text:#e8e8f0;
      --muted:#a0a0b0;
      --muted2:#606070;
      --accent:#6366f1;
      --glow:rgba(99,102,241,.16);
      --ok:#10b981;
      --bad:#ef4444;
      --warn:#f59e0b;
      --grad:linear-gradient(135deg,#6366f1 0%,#8b5cf6 100%);

      --kb:0px;
      --hh:64px;     /* header height (measured) */
      --ch:128px;    /* composer height (measured) */

      --r:14px;
      --ease:cubic-bezier(.2,.9,.2,1);
      --ease2:cubic-bezier(.4,0,.2,1);
    }

    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      background:var(--bg);
      color:var(--text);
      overflow-x:hidden;
    }

    body::before{
      content:'';
      position:fixed;
      inset:0;
      background:
        radial-gradient(circle at 18% 38%, rgba(99,102,241,.04) 0%, transparent 50%),
        radial-gradient(circle at 82% 78%, rgba(139,92,246,.04) 0%, transparent 55%);
      pointer-events:none;
      z-index:0;
    }

    /* Desktop layout (kept solid; mobile-first overrides below) */
    .container{
      max-width:980px;
      margin:0 auto;
      padding:28px 18px;
      position:relative;
      z-index:1;
    }
    .header{
      text-align:center;
      margin-bottom:18px;
    }
    .header h1{
      font-size:30px;
      font-weight:800;
      letter-spacing:-.6px;
      background:var(--grad);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      margin-bottom:6px;
    }
    .header p{color:var(--muted);font-size:14px}

    .grid{
      display:grid;
      grid-template-columns:1fr;
      gap:14px;
    }
    @media(min-width:900px){
      .grid{grid-template-columns:1.1fr .9fr; gap:18px;}
    }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--r);
      backdrop-filter:blur(10px);
      overflow:hidden;
      position:relative;
    }
    .card-inner{padding:16px}
    @media(min-width:900px){
      .card-inner{padding:18px}
    }

    .title{
      display:flex;
      align-items:center;
      gap:10px;
      font-size:12px;
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:1px;
      color:var(--muted);
      margin-bottom:10px;
    }
    .title::after{
      content:'';
      height:1px;
      flex:1;
      background:var(--border);
    }

    /* RESULTS */
    .results-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .sub{
      font-size:11px;
      color:var(--muted2);
      font-variant-numeric:tabular-nums;
      white-space:nowrap;
    }
    .placeholder{
      padding:22px 10px;
      text-align:center;
      color:var(--muted2);
      font-size:12px;
    }

    .bars{
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    /* Compact bar row */
    .row{
      background:var(--card2);
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 10px 10px;
    }
    .row-top{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      margin-bottom:7px;
    }
    .label{
      font-size:12px;
      font-weight:600;
      color:var(--text);
      max-width:72%;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .pct{
      font-size:12px;
      font-weight:700;
      color:var(--muted);
      font-variant-numeric:tabular-nums;
    }
    .track{
      height:10px;
      background:#13131c;
      border-radius:999px;
      overflow:hidden;
      position:relative;
    }
    .fill{
      height:100%;
      width:0%;
      background:var(--grad);
      border-radius:999px;
      transition:width 640ms var(--ease2);
      box-shadow:0 0 8px rgba(99,102,241,.28);
      position:relative;
    }
    .fill::after{
      content:'';
      position:absolute; inset:0;
      background:linear-gradient(90deg, transparent, rgba(255,255,255,.12), transparent);
      animation:shimmer 3.0s infinite;
      pointer-events:none;
    }
    @keyframes shimmer{0%{transform:translateX(-100%)}100%{transform:translateX(100%)}}

    /* INPUT */
    textarea{
      width:100%;
      min-height:140px;
      padding:12px 12px;
      border-radius:12px;
      background:#151520;
      border:1px solid var(--border);
      color:var(--text);
      font-size:14px;
      line-height:1.35;
      outline:none;
      resize:vertical;
      transition:border-color 140ms var(--ease2), box-shadow 140ms var(--ease2), opacity 140ms var(--ease2);
    }
    textarea::placeholder{color:var(--muted2)}
    textarea:focus{
      border-color:var(--accent);
      box-shadow:0 0 0 3px var(--glow);
    }
    textarea[readonly].locked{
      opacity:.72;
      cursor:not-allowed;
    }
    textarea[readonly].locked:focus{
      border-color:var(--border);
      box-shadow:none;
    }

    .queue{
      margin-top:8px;
      padding:9px 10px;
      border-radius:10px;
      background:rgba(245,158,11,.10);
      border:1px solid rgba(245,158,11,.25);
      color:var(--warn);
      font-size:11px;
      display:none;
    }

    .btn{
      margin-top:10px;
      display:none;
      width:100%;
      padding:11px 14px;
      border-radius:12px;
      border:none;
      background:var(--grad);
      color:white;
      font-weight:700;
      font-size:13px;
      cursor:pointer;
      box-shadow:0 6px 18px rgba(99,102,241,.22);
      transition:transform 140ms var(--ease2), opacity 140ms var(--ease2);
    }
    .btn:disabled{opacity:.65; cursor:not-allowed}
    .btn:active{transform:scale(.99)}

    .status{
      margin-top:10px;
      display:flex;
      align-items:center;
      gap:8px;
      font-size:11px;
      color:var(--muted);
    }
    .dot{
      width:8px;height:8px;border-radius:99px;
      background:var(--muted2);
      animation:pulse 2s infinite;
    }
    .dot.ok{background:var(--ok); box-shadow:0 0 8px rgba(16,185,129,.45)}
    .dot.bad{background:var(--bad); box-shadow:0 0 8px rgba(239,68,68,.45)}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}

    .meta{
      margin-top:6px;
      font-size:11px;
      color:var(--muted2);
    }

    .adv{
      margin-top:12px;
      padding-top:12px;
      border-top:1px solid var(--border);
    }
    .adv-btn{
      background:none;border:none;
      color:var(--muted);
      font-size:11px;
      font-weight:700;
      cursor:pointer;
      display:flex;
      align-items:center;
      gap:6px;
      padding:6px 0;
    }
    .adv-btn::after{content:'▼';font-size:10px;transition:transform 260ms var(--ease2)}
    .adv-btn.expanded::after{transform:rotate(180deg)}
    .adv-panel{
      max-height:0;
      overflow:hidden;
      opacity:0;
      transition:max-height 260ms var(--ease2), opacity 260ms var(--ease2);
    }
    .adv-panel.visible{max-height:900px; opacity:1; margin-top:10px;}
    .adv-row{display:flex;flex-direction:column;gap:7px;margin-bottom:10px;}
    .adv-label{
      font-size:11px;
      font-weight:700;
      color:var(--muted);
      text-transform:uppercase;
      letter-spacing:.6px;
    }
    .adv-input, select{
      padding:10px 11px;
      border-radius:10px;
      background:#151520;
      border:1px solid var(--border);
      color:var(--text);
      outline:none;
      font-size:12px;
    }
    .adv-actions{display:flex;gap:8px;flex-wrap:wrap;}
    .sec{
      padding:9px 10px;
      border-radius:10px;
      background:#151520;
      border:1px solid var(--border);
      color:var(--text);
      font-size:12px;
      font-weight:600;
      cursor:pointer;
    }
    .sec:active{transform:scale(.99)}
    .examples{display:none;margin-top:10px;}
    .examples.visible{display:block;}
    .eg-grid{display:grid;grid-template-columns:1fr 1.6fr;gap:8px}
    .stats{
      display:flex;gap:12px;flex-wrap:wrap;
      margin-top:10px;padding-top:10px;border-top:1px solid var(--border);
      font-size:11px;color:var(--muted);
    }
    .stats b{color:var(--text);font-weight:800}

    @media (prefers-reduced-motion: reduce){
      *{animation-duration:1ms !important; animation-iteration-count:1 !important; transition-duration:1ms !important;}
      .fill::after{display:none}
    }

    /* ============================================================
       MOBILE: ultra-compact app shell
       - header fixed (small)
       - results fixed between header & composer
       - composer fixed above keyboard
       - tiny input text/height
       ============================================================ */
    @media (max-width: 899px){
      .container{max-width:100%; padding:0;}

      .header{
        position:fixed;
        top:0; left:0; right:0;
        z-index:50;
        padding:10px 12px 8px;
        background:rgba(10,10,15,.92);
        backdrop-filter:blur(10px);
        border-bottom:1px solid var(--border);
        text-align:left;
      }
      .header h1{font-size:18px; margin:0 0 2px; letter-spacing:-.4px;}
      .header p{font-size:11px; line-height:1.2}

      .grid{display:block; padding:0;}

      /* Results pane: tight margins, scrollable */
      .results{
        position:fixed;
        left:10px; right:10px;
        top:calc(var(--hh) + 8px);
        bottom:calc(var(--ch) + var(--kb) + env(safe-area-inset-bottom) + 8px);
        z-index:20;
        overflow:auto;
        -webkit-overflow-scrolling:touch;
      }
      .results .card-inner{padding:12px;}

      /* Sticky results head to preserve context */
      .results-head{
        position:sticky;
        top:0;
        z-index:25;
        padding:6px 0 8px;
        background:rgba(15,15,21,.92);
        backdrop-filter:blur(10px);
      }

      .title{font-size:11px; margin-bottom:8px;}
      .sub{font-size:10px;}

      /* Even tighter bars */
      .bars{gap:7px;}
      .row{padding:9px 9px 9px;}
      .label{font-size:11px; max-width:70%;}
      .pct{font-size:11px;}
      .track{height:9px;}

      /* Composer: very compact */
      .composer{
        position:fixed;
        left:10px; right:10px;
        bottom:calc(var(--kb) + env(safe-area-inset-bottom) + 8px);
        z-index:40;
      }
      .composer .card-inner{padding:12px;}
      textarea{
        min-height:64px;
        max-height:16vh;
        font-size:12px;
        line-height:1.25;
        padding:10px 10px;
        resize:none;
      }
      .queue{font-size:10px; padding:8px 9px;}
      .btn{padding:10px 12px; font-size:12px; border-radius:12px;}
      .status{font-size:10px; margin-top:8px;}
      .meta{font-size:10px;}
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header" id="header">
      <h1>Wine Classifier</h1>
      <p>Paste a tasting note. Top probabilities update with bars.</p>
    </div>

    <div class="grid">
      <div class="card results results" id="resultsCard">
        <div class="card-inner">
          <div class="results-head">
            <div class="results-head">
              <div class="title" style="margin:0;">Predictions</div>
              <div class="sub" id="resultsSub">—</div>
            </div>
          </div>
          <div class="bars" id="bars">
            <div class="placeholder" id="placeholder">Type a tasting note to see probabilities.</div>
          </div>
        </div>
      </div>

      <div class="card composer" id="composer">
        <div class="card-inner">
          <div class="title">Tasting Note</div>
          <textarea id="text" placeholder="black cherry, oak, tannins…"></textarea>

          <div id="queueModeNotice" class="queue">
            Rate limited: real-time disabled. Request once; input locked while queued.
          </div>

          <button id="requestBtn" class="btn">Request Prediction</button>

          <div class="status">
            <span id="dot" class="dot"></span>
            <span id="statusText">Connecting…</span>
          </div>

          <div class="meta" id="meta"></div>

          <div class="adv">
            <button id="advancedToggle" class="adv-btn">Advanced</button>
            <div id="advancedPanel" class="adv-panel">
              <div class="adv-row">
                <label class="adv-label">API Endpoint</label>
                <input id="apiUrl" class="adv-input" type="text"
                       value="https://ectal-unbelievingly-shella.ngrok-free.dev/predict" />
              </div>

              <div class="adv-row">
                <label class="adv-label">Live Update Speed (ms)</label>
                <input id="debounceDelay" class="adv-input" type="number" value="200" min="80" max="1200" step="40" />
              </div>

              <div class="adv-actions">
                <button id="pingBtn" class="sec">Ping</button>
                <button id="loadExamplesBtn" class="sec">Examples</button>
              </div>

              <div id="examplesPanel" class="examples">
                <div class="eg-grid">
                  <select id="categorySelect"></select>
                  <select id="exampleSelect"></select>
                </div>
              </div>

              <div class="stats">
                <div>Client: <b id="clientIdEl">-</b></div>
                <div>Tokens: <b id="tokensEl">-</b></div>
                <div>Queue: <b id="queueEl">-</b></div>
                <div>Users(1h): <b id="usersHourEl">-</b></div>
              </div>
            </div>
          </div>

        </div>
      </div>

    </div>
  </div>

  <script>
    // ============================================================
    // GUARANTEE:
    // - No background polling intervals.
    // - Ping uses /api/status only.
    // - /predict is called ONLY on explicit user actions:
    //     (1) typing (input event) when realtimeEnabled
    //     (2) clicking Request Prediction (queue mode)
    //     (3) selecting an example
    // ============================================================

    // ---------- Keyboard inset via VisualViewport ----------
    (function setupKeyboardInset(){
      const root = document.documentElement;
      function update() {
        if (!window.visualViewport) { root.style.setProperty('--kb','0px'); return; }
        const vv = window.visualViewport;
        const inset = Math.max(0, window.innerHeight - vv.height - vv.offsetTop);
        root.style.setProperty('--kb', inset + 'px');
      }
      update();
      window.addEventListener('resize', update);
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', update);
        window.visualViewport.addEventListener('scroll', update);
      }
    })();

    // ---------- Debounce ----------
    function makeDebounce(fn, getDelay){
      let t=null;
      const w=(...a)=>{ if(t)clearTimeout(t); t=setTimeout(()=>fn(...a), getDelay()); };
      w.cancel=()=>{ if(t)clearTimeout(t); t=null; };
      return w;
    }

    // ---------- Elements ----------
    const headerEl = document.getElementById('header');
    const composerEl = document.getElementById('composer');

    const textEl = document.getElementById('text');
    const barsEl = document.getElementById('bars');
    const placeholderEl = document.getElementById('placeholder');

    const apiUrlEl = document.getElementById('apiUrl');
    const metaEl = document.getElementById('meta');
    const statusText = document.getElementById('statusText');
    const dot = document.getElementById('dot');
    const resultsSub = document.getElementById('resultsSub');

    const requestBtn = document.getElementById('requestBtn');
    const queueModeNotice = document.getElementById('queueModeNotice');

    const advancedToggle = document.getElementById('advancedToggle');
    const advancedPanel = document.getElementById('advancedPanel');

    const debounceDelayEl = document.getElementById('debounceDelay');
    const pingBtn = document.getElementById('pingBtn');
    const loadExamplesBtn = document.getElementById('loadExamplesBtn');

    const examplesPanel = document.getElementById('examplesPanel');
    const categorySelect = document.getElementById('categorySelect');
    const exampleSelect = document.getElementById('exampleSelect');

    const clientIdEl = document.getElementById('clientIdEl');
    const tokensEl = document.getElementById('tokensEl');
    const queueEl = document.getElementById('queueEl');
    const usersHourEl = document.getElementById('usersHourEl');

    // ---------- State ----------
    let advancedVisible = false;
    let pendingPredict = false;

    // "Realtime" is enabled until we hit 429 or status says no tokens/backlog.
    let realtimeEnabled = true;

    // Connectivity: ping once; then only on wake/failure/manual
    let isConnected = false;
    let lastGoodAt = 0;
    let lastActivityAt = Date.now();
    const inactivityMs = 2 * 60 * 1000; // 2min
    let pingInFlight = false;

    // ---------- Measurements to prevent overlap ----------
    function updateMeasures(){
      const root = document.documentElement;
      const hh = headerEl ? headerEl.getBoundingClientRect().height : 64;
      const ch = composerEl ? composerEl.getBoundingClientRect().height : 128;
      root.style.setProperty('--hh', Math.ceil(hh) + 'px');
      root.style.setProperty('--ch', Math.ceil(ch) + 'px');
    }
    updateMeasures();
    window.addEventListener('resize', updateMeasures);
    if (window.visualViewport) window.visualViewport.addEventListener('resize', updateMeasures);

    // ---------- Status ----------
    function setStatus(ok,msg){
      statusText.textContent = msg;
      dot.className = 'dot ' + (ok ? 'ok' : 'bad');
    }

    function markActivity(){ lastActivityAt = Date.now(); }

    // ---------- Client ID ----------
    let clientId = localStorage.getItem('qea_client_id');
    if (!clientId) {
      clientId = (window.crypto && crypto.randomUUID) ? crypto.randomUUID() : ('c-' + Math.random().toString(36).slice(2,12));
      localStorage.setItem('qea_client_id', clientId);
    }
    clientIdEl.textContent = clientId.slice(0,8) + '…';

    // ---------- Input lock in queue mode ----------
    function setInputLocked(locked, reason){
      textEl.readOnly = locked;
      textEl.classList.toggle('locked', locked);
      if (locked && reason) {
        textEl.setAttribute('aria-busy', 'true');
        textEl.setAttribute('aria-label', `Input locked: ${reason}`);
      } else {
        textEl.removeAttribute('aria-busy');
        textEl.removeAttribute('aria-label');
      }
    }
    textEl.addEventListener('beforeinput', (e)=>{ if (textEl.readOnly) e.preventDefault(); });
    textEl.addEventListener('keydown', (e)=>{
      if (!textEl.readOnly) return;
      const block = (e.key.length === 1 || e.key === 'Backspace' || e.key === 'Delete' || e.key === 'Enter');
      if (block) e.preventDefault();
    });

    // ---------- Fetch helper ----------
    async function fetchJsonWithRetry(url, opts={}, retries=1, backoff=200){
      let last=null;
      for (let i=0;i<=retries;i++){
        try{
          const res = await fetch(url, opts);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const ct = res.headers.get('content-type') || '';
          if (!ct.includes('application/json')) {
            const txt = await res.text();
            throw new Error('non-json:' + txt.slice(0,200));
          }
          return await res.json();
        } catch(e){
          last=e;
          if (i<retries) await new Promise(r=>setTimeout(r, backoff*(i+1)));
        }
      }
      throw last;
    }

    function baseUrl(){
      const api = apiUrlEl.value.trim();
      return api.replace(/\/predict\/?$/i,'').replace(/\/$/,'');
    }

    // ---------- Rate-mode UI ----------
    function applyRateModeFrom(tokens, queueLen){
      const t = parseInt(tokens,10);
      const q = parseInt(queueLen,10);
      const shouldRealtime = (Number.isFinite(t) ? t : 0) > 0 && (Number.isFinite(q) ? q : 0) === 0;

      realtimeEnabled = shouldRealtime;

      if (realtimeEnabled) {
        requestBtn.style.display = 'none';
        queueModeNotice.style.display = 'none';
        setInputLocked(false);
      } else {
        requestBtn.style.display = 'block';
        requestBtn.textContent = 'Request Prediction';
        queueModeNotice.style.display = 'block';
        setInputLocked(true, 'waiting in queue');
      }
      setTimeout(updateMeasures, 0);
    }

    // ---------- Ping: /api/status only ----------
    async function pingIfNeeded(force=false){
      if (!force && isConnected) return true;
      if (pingInFlight) return false;
      pingInFlight = true;

      const url = baseUrl() + '/api/status';
      const t0 = performance.now();

      try{
        const data = await fetchJsonWithRetry(url, {
          method:'POST',
          headers:{ 'Content-Type':'text/plain', 'Accept':'application/json' },
          body: clientId
        }, 1, 200);

        const dt = Math.round(performance.now()-t0);

        isConnected = true;
        lastGoodAt = Date.now();

        setStatus(true, `Connected (${dt}ms)`);
        metaEl.textContent = `Status OK • ${dt}ms`;
        resultsSub.textContent = `${dt}ms`;

        tokensEl.textContent = data.tokens;
        queueEl.textContent = data.queue_len;
        usersHourEl.textContent = data.users_past_hour;

        applyRateModeFrom(data.tokens, data.queue_len);
        setTimeout(updateMeasures, 0);
        return true;
      } catch(e){
        isConnected = false;
        setStatus(false, 'Disconnected');
        metaEl.textContent = `Ping failed: ${String(e).slice(0,120)}`;
        resultsSub.textContent = 'offline';

        // Offer reconnect button
        requestBtn.style.display = 'block';
        requestBtn.textContent = 'Reconnect';
        queueModeNotice.style.display = 'none';
        setInputLocked(false);

        setTimeout(updateMeasures, 0);
        return false;
      } finally {
        pingInFlight = false;
      }
    }

    function maybePingOnWake(){
      const now = Date.now();
      const inactive = now - lastActivityAt;
      const stale = now - lastGoodAt;
      if (!isConnected || inactive > inactivityMs || stale > 10*60*1000) pingIfNeeded(true);
    }

    document.addEventListener('visibilitychange', ()=>{
      if (document.visibilityState === 'visible') maybePingOnWake();
    });
    window.addEventListener('offline', ()=>{
      isConnected = false;
      setStatus(false,'Offline');
      resultsSub.textContent='offline';
    });
    window.addEventListener('online', ()=>{ pingIfNeeded(true); });

    ['pointerdown','keydown','touchstart','focus'].forEach(evt=>{
      window.addEventListener(evt, markActivity, {passive:true});
    });

    pingBtn.addEventListener('click', async ()=>{
      markActivity();
      await pingIfNeeded(true);
    });

    apiUrlEl.addEventListener('change', ()=>{
      isConnected = false;
      pingIfNeeded(true);
    });

    // ---------- Bars rendering (compact, readable) ----------
    const rowByLabel = new Map();
    let renderedOnce = false;

    function fmtPct(v){ return v.toFixed(1) + '%'; }

    function tweenPct(el, from, to, ms){
      if (!Number.isFinite(from)) from = 0;
      if (!Number.isFinite(to)) to = 0;
      const start = performance.now();
      const ease = t => t<.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;

      function step(now){
        const t = Math.min(1, (now-start)/ms);
        const v = from + (to-from)*ease(t);
        el.textContent = fmtPct(v);
        if (t<1) requestAnimationFrame(step);
        else el.textContent = fmtPct(to);
      }
      requestAnimationFrame(step);
    }

    function ensureRow(label){
      let obj = rowByLabel.get(label);
      if (obj && obj.row.isConnected) return obj;

      const row = document.createElement('div');
      row.className = 'row';

      const top = document.createElement('div');
      top.className = 'row-top';

      const labelEl = document.createElement('div');
      labelEl.className = 'label';
      labelEl.textContent = label;

      const pctEl = document.createElement('div');
      pctEl.className = 'pct';
      pctEl.textContent = '0.0%';

      top.appendChild(labelEl);
      top.appendChild(pctEl);

      const track = document.createElement('div');
      track.className = 'track';

      const fill = document.createElement('div');
      fill.className = 'fill';
      fill.style.width = '0%';

      track.appendChild(fill);
      row.appendChild(top);
      row.appendChild(track);

      obj = { row, fill, pctEl, last: 0 };
      rowByLabel.set(label, obj);
      return obj;
    }

    function render(preds, metaText){
      let entries = Object.entries(preds || {}).sort((a,b)=>b[1]-a[1]);

      // Mobile-first compactness: show top 5 only. Desktop still ok (bars are small).
      entries = entries.slice(0, 5);

      if (!entries.length) {
        barsEl.innerHTML = '';
        barsEl.appendChild(placeholderEl);
        placeholderEl.style.display = 'block';
        resultsSub.textContent = metaText || '—';
        return;
      }

      placeholderEl.style.display = 'none';

      // Rebuild to keep it deterministic and compact (5 cards only)
      barsEl.innerHTML = '';

      for (const [label, pct] of entries) {
        const obj = ensureRow(label);
        barsEl.appendChild(obj.row);

        const w = Math.max(0, Math.min(100, Number(pct) || 0));
        obj.fill.style.width = w + '%';
        tweenPct(obj.pctEl, obj.last, w, 520);
        obj.last = w;
      }

      resultsSub.textContent = metaText || '—';
      renderedOnce = true;
      setTimeout(updateMeasures, 0);
    }

    // ---------- Predict ----------
    async function predictNow(){
      if (pendingPredict) return;

      const text = textEl.value.trim();
      const apiUrl = apiUrlEl.value.trim();

      if (!text) {
        render({}, '—');
        metaEl.textContent = '';
        return;
      }

      pendingPredict = true;
      requestBtn.disabled = true;

      if (!realtimeEnabled) {
        setInputLocked(true, 'waiting in queue');
        setStatus(false, 'Waiting in queue…');
        requestBtn.textContent = 'Processing…';
      }

      const t0 = performance.now();

      try{
        const res = await fetch(apiUrl, {
          method:'POST',
          headers:{
            'Content-Type':'application/json',
            'Accept':'application/json',
            'x-client-id': clientId
          },
          body: JSON.stringify({ text })
        });

        if (!res.ok) {
          let msg = `HTTP ${res.status}`;
          try {
            const ct = res.headers.get('content-type') || '';
            if (ct.includes('application/json')) {
              const j = await res.json();
              if (j?.detail) msg = j.detail;
            }
          } catch {}

          if (res.status === 429) {
            realtimeEnabled = false;
            setStatus(false, 'Rate limited');
            metaEl.textContent = msg;
            requestBtn.style.display = 'block';
            requestBtn.textContent = 'Request Prediction';
            queueModeNotice.style.display = 'block';
            setInputLocked(true, 'waiting in queue');
          } else if (res.status === 413) {
            setStatus(false, 'Too long');
            metaEl.textContent = msg;
          } else {
            setStatus(false, 'Error');
            metaEl.textContent = msg;
          }

          isConnected = false; // allow wake ping later
          return;
        }

        const ct = res.headers.get('content-type') || '';
        if (!ct.includes('application/json')) {
          const txt = await res.text();
          throw new Error('non-json:' + txt.slice(0,200));
        }

        const data = await res.json();
        const dt = Math.round(performance.now() - t0);

        isConnected = true;
        lastGoodAt = Date.now();

        setStatus(true, `OK (${dt}ms)`);
        metaEl.textContent = `Device: ${data.device ?? 'unknown'} • ${dt}ms`;

        render(data.predictions || {}, `${dt}ms`);

        // Optional one-shot status sync AFTER successful predict (no polling)
        pingIfNeeded(true);

      } catch(e){
        setStatus(false, 'Error');
        metaEl.textContent = String(e).slice(0,180);
        isConnected = false;
      } finally {
        pendingPredict = false;
        requestBtn.disabled = false;

        if (requestBtn.textContent === 'Reconnect') {
          // leave as-is
        } else if (!realtimeEnabled) {
          requestBtn.textContent = 'Request Prediction';
          setInputLocked(true, 'waiting in queue');
        } else {
          requestBtn.textContent = 'Request Prediction';
          setInputLocked(false);
        }
      }
    }

    // Debounce config
    let debounceDelay = 200;
    const saved = localStorage.getItem('qea_debounce_delay');
    if (saved) {
      const n = parseInt(saved,10);
      if (Number.isFinite(n)) debounceDelay = n;
    }
    debounceDelayEl.value = debounceDelay;

    debounceDelayEl.addEventListener('input', (e)=>{
      const v = parseInt(e.target.value,10);
      if (v>=80 && v<=1200) {
        debounceDelay = v;
        localStorage.setItem('qea_debounce_delay', String(v));
      }
    });

    const predictDebounced = makeDebounce(predictNow, ()=>debounceDelay);

    // Predict only on user typing when realtime enabled
    textEl.addEventListener('input', ()=>{
      markActivity();
      maybePingOnWake(); // ping only if stale/offline; never calls /predict
      if (realtimeEnabled && !pendingPredict) predictDebounced();
    });

    // Button for queue mode OR reconnect (explicit user action)
    requestBtn.addEventListener('click', async ()=>{
      markActivity();
      if (requestBtn.textContent === 'Reconnect') {
        await pingIfNeeded(true);
        return;
      }
      await predictNow();
    });

    // ---------- Advanced / examples ----------
    advancedToggle.addEventListener('click', ()=>{
      advancedVisible = !advancedVisible;
      advancedToggle.classList.toggle('expanded', advancedVisible);
      advancedPanel.classList.toggle('visible', advancedVisible);
      setTimeout(updateMeasures, 0);
    });

    async function loadExamples(){
      const url = baseUrl() + '/api/examples';
      const data = await fetchJsonWithRetry(url, {
        method:'POST',
        headers:{ 'Content-Type':'text/plain', 'Accept':'application/json' },
        body: clientId
      }, 2, 250);

      categorySelect.innerHTML = '';
      for (const k of Object.keys(data)) {
        const o = document.createElement('option');
        o.value = k; o.textContent = k;
        categorySelect.appendChild(o);
      }

      function fillCategory(cat){
        const arr = data[cat] || [];
        exampleSelect.innerHTML = '';
        for (const ex of arr) {
          const o = document.createElement('option');
          o.value = ex;
          o.textContent = ex.length > 72 ? ex.slice(0,72) + '…' : ex;
          exampleSelect.appendChild(o);
        }
      }

      if (categorySelect.options.length) {
        categorySelect.selectedIndex = 0;
        fillCategory(categorySelect.value);
      }

      examplesPanel.classList.add('visible');
      examplesPanel.classList.toggle('visible', true);
      examplesPanel.style.display = 'block';
      setStatus(true, 'Examples loaded');
      setTimeout(updateMeasures, 0);

      categorySelect.onchange = () => { fillCategory(categorySelect.value); setTimeout(updateMeasures,0); };
    }

    loadExamplesBtn.addEventListener('click', async ()=>{
      markActivity();
      maybePingOnWake();
      try{
        await loadExamples();
      } catch(e){
        setStatus(false,'Examples failed');
        metaEl.textContent = String(e).slice(0,160);
      }
    });

    exampleSelect.addEventListener('change', ()=>{
      markActivity();
      maybePingOnWake();
      const v = exampleSelect.value || '';
      if (!v) return;
      textEl.value = v;
      // Explicit user action: OK to predict once
      if (realtimeEnabled && !pendingPredict) predictDebounced();
      else predictNow();
    });

    // ---------- Init: one-shot ping ----------
    setStatus(false,'Connecting…');
    pingIfNeeded(true);
    updateMeasures();
  </script>
</body>
</html>
