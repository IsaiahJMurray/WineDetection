<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Wine Classifier</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

    :root {
      --bg-primary: #0a0a0f;
      --bg-secondary: #0f0f15;
      --bg-tertiary: #151520;
      --border: #1a1a25;
      --border-light: #252530;
      --text-primary: #e8e8f0;
      --text-secondary: #a0a0b0;
      --text-tertiary: #606070;
      --accent: #6366f1;
      --accent-glow: rgba(99, 102, 241, 0.15);
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --gradient: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);

      --kb-inset: 0px;
      --header-h: 120px;
      --composer-h: 240px;

      --ease-out: cubic-bezier(0.2, 0.9, 0.2, 1);
      --ease-inout: cubic-bezier(0.4, 0, 0.2, 1);
      --dur-fast: 160ms;
      --dur-med: 360ms;
      --dur-slow: 720ms;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      overflow-x: hidden;
    }

    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background:
        radial-gradient(circle at 20% 50%, rgba(99, 102, 241, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(139, 92, 246, 0.03) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    /* Desktop container */
    .container {
      max-width: 1000px;
      margin: 0 auto;
      padding: 40px 24px;
      position: relative;
      z-index: 1;
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
      animation: fadeInDown 0.6s ease-out;
    }

    .header h1 {
      font-size: 36px;
      font-weight: 700;
      background: var(--gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 10px;
      letter-spacing: -0.5px;
    }

    .header p {
      color: var(--text-secondary);
      font-size: 16px;
      font-weight: 400;
    }

    .main-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 24px;
      align-items: start;
    }

    @media (min-width: 900px) {
      .main-grid { grid-template-columns: 1fr 1fr; }
    }

    .card {
      background: rgba(15, 15, 21, 0.86);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      backdrop-filter: blur(10px);
      transition: border-color var(--dur-fast) var(--ease-inout), box-shadow var(--dur-fast) var(--ease-inout);
      position: relative;
      overflow: hidden;
    }

    .card:hover {
      border-color: var(--border-light);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .card-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .card-title::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--border);
      opacity: 0.9;
    }

    /* Results header row */
    .results-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 10px;
    }

    .results-sub {
      font-size: 12px;
      color: var(--text-tertiary);
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }

    .results-placeholder {
      color: var(--text-tertiary);
      font-size: 14px;
      text-align: center;
      padding: 52px 16px;
    }

    /* Bars */
    .bars {
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
    }

    /* Desktop row layout: label | bar | pct */
    .bar-row {
      display: grid;
      grid-template-columns: minmax(130px, 170px) 1fr 74px;
      gap: 14px;
      align-items: center;
      will-change: transform;
      transform: translateZ(0);
    }

    .bar-top {
      display: contents; /* desktop: let label/pct take grid slots */
    }

    .bar-label {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .bar-track {
      height: 8px;
      background: var(--bg-tertiary);
      border-radius: 999px;
      overflow: hidden;
      position: relative;
    }

    .bar-fill {
      height: 100%;
      background: var(--gradient);
      border-radius: 999px;
      width: 0%;
      box-shadow: 0 0 8px rgba(99, 102, 241, 0.35);
      transition: width var(--dur-slow) var(--ease-inout);
      position: relative;
    }

    .bar-fill::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.14), transparent);
      animation: shimmer 3.2s infinite;
      pointer-events: none;
    }

    .bar-pct {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-secondary);
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    /* Entry/exit animation (no height changes) */
    .enter {
      opacity: 0;
      transform: translateY(10px) scale(0.98);
      animation: popIn var(--dur-med) var(--ease-out) forwards;
    }

    .exit {
      opacity: 1;
      transform: translateY(0) scale(1);
      transition: opacity var(--dur-fast) var(--ease-inout), transform var(--dur-fast) var(--ease-inout);
    }

    .exit.final {
      opacity: 0;
      transform: translateY(-6px) scale(0.98);
    }

    @keyframes popIn { to { opacity: 1; transform: translateY(0) scale(1); } }
    @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
    @keyframes fadeInDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }

    /* Textarea */
    textarea {
      width: 100%;
      min-height: 170px;
      padding: 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 12px;
      color: var(--text-primary);
      font-size: 15px;
      font-family: inherit;
      line-height: 1.6;
      outline: none;
      transition: border-color var(--dur-fast) var(--ease-inout), box-shadow var(--dur-fast) var(--ease-inout), background var(--dur-fast) var(--ease-inout), opacity var(--dur-fast) var(--ease-inout);
      resize: vertical;
    }

    textarea::placeholder { color: var(--text-tertiary); }
    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-glow);
      background: rgba(15, 15, 21, 0.9);
    }

    /* Lock state: prevent edits but allow scroll/copy */
    textarea[readonly].locked { opacity: 0.75; cursor: not-allowed; }
    textarea[readonly].locked:focus { border-color: var(--border); box-shadow: none; }

    /* Queue notice */
    .queue-notice {
      margin-top: 12px;
      padding: 12px 14px;
      background: rgba(245, 158, 11, 0.1);
      border: 1px solid rgba(245, 158, 11, 0.3);
      border-radius: 10px;
      color: var(--warning);
      font-size: 13px;
      display: none;
    }

    /* Request button */
    .request-btn {
      margin-top: 14px;
      padding: 12px 18px;
      background: var(--gradient);
      border: none;
      border-radius: 10px;
      color: white;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform var(--dur-fast) var(--ease-inout), box-shadow var(--dur-fast) var(--ease-inout), opacity var(--dur-fast) var(--ease-inout);
      display: none;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    .request-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4); }
    .request-btn:disabled { opacity: 0.6; cursor: not-allowed; }

    .status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 14px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-tertiary);
      animation: pulse 2s infinite;
    }
    .status-dot.ok { background: var(--success); box-shadow: 0 0 8px rgba(16, 185, 129, 0.5); }
    .status-dot.bad { background: var(--error); box-shadow: 0 0 8px rgba(239, 68, 68, 0.5); }

    .meta { margin-top: 10px; font-size: 12px; color: var(--text-tertiary); }

    /* Advanced */
    .advanced-toggle {
      margin-top: 20px;
      padding-top: 18px;
      border-top: 1px solid var(--border);
    }

    .advanced-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      padding: 8px 0;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .advanced-btn:hover { color: var(--accent); }
    .advanced-btn::after { content: '▼'; font-size: 10px; transition: transform var(--dur-med) var(--ease-inout); }
    .advanced-btn.expanded::after { transform: rotate(180deg); }

    .advanced-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height var(--dur-med) var(--ease-inout), opacity var(--dur-med) var(--ease-inout);
      opacity: 0;
    }

    .advanced-panel.visible { max-height: 1000px; opacity: 1; margin-top: 16px; }

    .advanced-section { display: flex; flex-direction: column; gap: 14px; }
    .advanced-row { display: flex; flex-direction: column; gap: 8px; }

    .advanced-label {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .advanced-input, select {
      padding: 10px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 13px;
      font-family: inherit;
      outline: none;
    }

    .advanced-input:focus, select:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-glow);
    }

    .advanced-buttons { display: flex; gap: 8px; flex-wrap: wrap; }

    .btn-secondary {
      padding: 8px 14px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
    }

    .btn-secondary:hover { border-color: var(--border-light); }

    .examples-panel { margin-top: 10px; display: none; }
    .examples-panel.visible { display: block; }
    .examples-grid { display: grid; grid-template-columns: 1fr 2fr; gap: 10px; }

    .stats-row {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      margin-top: 10px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .stat-item { font-size: 12px; color: var(--text-secondary); }
    .stat-value { color: var(--text-primary); font-weight: 600; }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      * { animation-duration: 1ms !important; animation-iteration-count: 1 !important; transition-duration: 1ms !important; }
      .bar-fill::after { display: none; }
    }

    /* ----------------------------------------------------
       MOBILE APP SHELL (no overlap; header/results/composer)
       ---------------------------------------------------- */
    @media (max-width: 899px) {
      .container {
        max-width: 100%;
        padding: 0;
      }

      /* Fixed header at top */
      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 30;
        margin: 0;
        padding: 16px 16px 12px;
        background: rgba(10,10,15,0.92);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid var(--border);
        text-align: left;
      }

      .header h1 { font-size: 24px; margin-bottom: 4px; }
      .header p { font-size: 13px; }

      /* Disable hover visuals on touch */
      .card:hover { box-shadow: none; }

      /* We do not use grid flow on mobile */
      .main-grid { display: block; padding: 0; }

      /* Results pane fixed between header and composer */
      .results-card {
        position: fixed;
        left: 12px;
        right: 12px;
        top: calc(8px + var(--header-h));
        bottom: calc(12px + var(--composer-h) + var(--kb-inset) + env(safe-area-inset-bottom));
        z-index: 10;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        padding: 14px;
      }

      .results-head {
        position: sticky;
        top: 0;
        z-index: 12;
        padding: 8px 0 10px;
        background: rgba(15, 15, 21, 0.92);
        backdrop-filter: blur(10px);
      }

      /* Composer fixed above keyboard */
      .input-card {
        position: fixed;
        left: 12px;
        right: 12px;
        bottom: calc(12px + var(--kb-inset) + env(safe-area-inset-bottom));
        z-index: 20;
        padding: 14px;
      }

      textarea {
        min-height: 96px;
        max-height: 22vh;
        resize: none;
      }

      /* Mobile prediction layout: condensed & readable */
      .bar-row {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 10px 10px;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: rgba(21, 21, 32, 0.55);
      }

      .bar-top {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px;
      }

      .bar-label {
        font-size: 13px;
        max-width: 70%;
      }

      .bar-pct {
        font-size: 13px;
        text-align: right;
      }

      .bar-track { height: 10px; }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header" id="header">
      <h1>Wine Classifier</h1>
      <p>Enter a tasting note to predict the variety</p>
    </div>

    <div class="main-grid">
      <div class="card results-card" id="resultsCard">
        <div class="results-head">
          <div class="card-title" style="margin-bottom:0;">Predictions</div>
          <div class="results-sub" id="resultsSub">—</div>
        </div>

        <div class="bars" id="bars">
          <div class="results-placeholder" id="placeholder">Enter a tasting note to see predictions</div>
        </div>
      </div>

      <div class="card input-card" id="composer">
        <div class="card-title">Tasting Note</div>
        <textarea id="text" placeholder="e.g., black cherry, leather, cedar, firm tannins, smoky finish..."></textarea>

        <div id="queueModeNotice" class="queue-notice">
          ⚠️ Rate limited: real-time updates disabled. Requests are queued; editing is temporarily locked.
        </div>

        <button id="requestBtn" class="request-btn">Request Prediction</button>

        <div class="status-indicator">
          <span id="dot" class="status-dot"></span>
          <span id="statusText">Connecting...</span>
        </div>

        <div class="meta" id="meta"></div>

        <div class="advanced-toggle">
          <button id="advancedToggle" class="advanced-btn">Advanced Settings</button>
          <div id="advancedPanel" class="advanced-panel">
            <div class="advanced-section">
              <div class="advanced-row">
                <label class="advanced-label">API Endpoint</label>
                <input id="apiUrl" type="text" class="advanced-input" value="https://ectal-unbelievingly-shella.ngrok-free.dev/predict" />
              </div>

              <div class="advanced-row">
                <label class="advanced-label">Live Update Speed (ms)</label>
                <input id="debounceDelay" type="number" class="advanced-input" value="150" min="50" max="1000" step="50" />
              </div>

              <div class="advanced-buttons">
                <button id="pingBtn" class="btn-secondary">Ping</button>
                <button id="loadExamplesBtn" class="btn-secondary">Load Examples</button>
              </div>

              <div id="examplesPanel" class="examples-panel">
                <div class="examples-grid">
                  <select id="categorySelect"></select>
                  <select id="exampleSelect"></select>
                </div>
              </div>

              <div class="stats-row">
                <div class="stat-item">Client ID: <span class="stat-value" id="clientIdEl">-</span></div>
                <div class="stat-item">Tokens: <span class="stat-value" id="tokensEl">-</span></div>
                <div class="stat-item">Queue: <span class="stat-value" id="queueEl">-</span></div>
                <div class="stat-item">Users (1h): <span class="stat-value" id="usersHourEl">-</span></div>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script>
    // ============================================================
    // GUARANTEE: This file will NOT call /predict repeatedly without input.
    //
    // /predict is called ONLY by:
    //   1) textarea "input" event (realtimeEnabled === true)
    //   2) clicking "Request Prediction" (queue mode)
    //   3) selecting an example (explicit user action)
    //
    // Ping uses /api/status ONLY and never triggers /predict.
    // No setInterval polling exists.
    // ============================================================

    // ---------------------------
    // VisualViewport keyboard inset
    // ---------------------------
    (function setupKeyboardInset(){
      const root = document.documentElement;
      function updateInset() {
        if (!window.visualViewport) {
          root.style.setProperty('--kb-inset', '0px');
          return;
        }
        const vv = window.visualViewport;
        const diff = Math.max(0, window.innerHeight - vv.height - vv.offsetTop);
        root.style.setProperty('--kb-inset', diff + 'px');
      }
      updateInset();
      window.addEventListener('resize', updateInset);
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', updateInset);
        window.visualViewport.addEventListener('scroll', updateInset);
      }
    })();

    function makeDebounce(fn, getDelayMs) {
      let t = null;
      const wrapped = (...args) => {
        if (t) clearTimeout(t);
        t = setTimeout(() => fn(...args), getDelayMs());
      };
      wrapped.cancel = () => { if (t) clearTimeout(t); t = null; };
      return wrapped;
    }

    // Elements
    const headerEl = document.getElementById("header");
    const composerEl = document.getElementById("composer");

    const textEl = document.getElementById("text");
    const barsEl = document.getElementById("bars");
    const placeholderEl = document.getElementById("placeholder");

    const apiUrlEl = document.getElementById("apiUrl");
    const metaEl = document.getElementById("meta");
    const statusText = document.getElementById("statusText");
    const dot = document.getElementById("dot");
    const resultsSub = document.getElementById("resultsSub");

    const pingBtn = document.getElementById("pingBtn");
    const loadExamplesBtn = document.getElementById("loadExamplesBtn");
    const examplesPanel = document.getElementById("examplesPanel");
    const categorySelect = document.getElementById("categorySelect");
    const exampleSelect = document.getElementById("exampleSelect");

    const clientIdEl = document.getElementById("clientIdEl");
    const tokensEl = document.getElementById("tokensEl");
    const queueEl = document.getElementById("queueEl");
    const usersHourEl = document.getElementById("usersHourEl");

    const requestBtn = document.getElementById("requestBtn");
    const queueModeNotice = document.getElementById("queueModeNotice");

    const advancedToggle = document.getElementById("advancedToggle");
    const advancedPanel = document.getElementById("advancedPanel");
    const debounceDelayEl = document.getElementById("debounceDelay");

    // State
    let pendingRequest = false;
    let advancedVisible = false;

    // Realtime mode is enabled by default, but can be disabled on 429.
    // We also update it opportunistically from /api/status responses.
    let realtimeEnabled = true;

    // Connectivity state: ping once, then avoid pings until "wake" events.
    let isConnected = false;
    let lastGoodAt = 0;
    let lastActivityAt = Date.now();
    const inactivityMs = 2 * 60 * 1000; // 2 minutes
    let pingInFlight = false;

    function markActivity() { lastActivityAt = Date.now(); }

    // Debounce delay
    let debounceDelay = 150;
    const savedDelay = localStorage.getItem('qea_debounce_delay');
    if (savedDelay) {
      const n = parseInt(savedDelay, 10);
      if (Number.isFinite(n)) debounceDelay = n;
    }
    debounceDelayEl.value = debounceDelay;

    debounceDelayEl.addEventListener('input', (e) => {
      const value = parseInt(e.target.value, 10);
      if (value >= 50 && value <= 1000) {
        debounceDelay = value;
        localStorage.setItem('qea_debounce_delay', String(value));
      }
    });

    // Advanced toggle
    advancedToggle.addEventListener('click', () => {
      advancedVisible = !advancedVisible;
      advancedToggle.classList.toggle('expanded', advancedVisible);
      advancedPanel.classList.toggle('visible', advancedVisible);
      setTimeout(updateShellMeasurements, 0);
    });

    function setStatus(ok, msg) {
      statusText.textContent = msg;
      dot.className = "status-dot " + (ok ? "ok" : "bad");
    }

    // Client id
    let clientId = localStorage.getItem('qea_client_id');
    if (!clientId) {
      if (window.crypto && crypto.randomUUID) clientId = crypto.randomUUID();
      else clientId = 'c-' + Math.random().toString(36).slice(2, 12);
      localStorage.setItem('qea_client_id', clientId);
    }
    clientIdEl.textContent = clientId.substring(0, 8) + '...';

    // Measure header and composer so mobile panes never overlap
    function updateShellMeasurements() {
      const root = document.documentElement;

      const headerH = headerEl ? headerEl.getBoundingClientRect().height : 120;
      root.style.setProperty('--header-h', Math.ceil(headerH) + 'px');

      const composerH = composerEl ? composerEl.getBoundingClientRect().height : 240;
      root.style.setProperty('--composer-h', Math.ceil(composerH) + 'px');
    }

    // call often on layout-affecting events
    updateShellMeasurements();
    window.addEventListener('resize', updateShellMeasurements);
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', updateShellMeasurements);
    }

    // Input lock (queue mode)
    function setInputLocked(locked, reason) {
      textEl.readOnly = locked;
      textEl.classList.toggle('locked', locked);

      if (locked && reason) {
        textEl.setAttribute('aria-busy', 'true');
        textEl.setAttribute('aria-label', `Input locked: ${reason}`);
      } else {
        textEl.removeAttribute('aria-busy');
        textEl.removeAttribute('aria-label');
      }
    }

    // Harden readonly
    textEl.addEventListener('beforeinput', (e) => {
      if (textEl.readOnly) e.preventDefault();
    });
    textEl.addEventListener('keydown', (e) => {
      if (!textEl.readOnly) return;
      const block = (e.key.length === 1 || e.key === "Backspace" || e.key === "Delete" || e.key === "Enter");
      if (block) e.preventDefault();
    });

    // Fetch helper
    async function fetchJsonWithRetry(url, opts = {}, retries = 1, backoff = 200) {
      let lastErr = null;
      for (let attempt = 0; attempt <= retries; attempt++) {
        try {
          const res = await fetch(url, opts);
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const ct = res.headers.get('content-type') || '';
          if (!ct.includes('application/json')) {
            const txt = await res.text();
            throw new Error('non-json:' + txt.slice(0, 200));
          }
          return await res.json();
        } catch (e) {
          lastErr = e;
          if (attempt < retries) await new Promise(r => setTimeout(r, backoff * (attempt + 1)));
        }
      }
      throw lastErr;
    }

    function baseUrl() {
      const api = apiUrlEl.value.trim();
      return api.replace(/\/predict\/?$/i, "").replace(/\/$/, "");
    }

    // ---------------------------
    // Ping (/api/status) once, then only on "wake" events / failures / manual ping.
    // Does NOT call /predict. Does NOT schedule polling.
    // ---------------------------
    async function pingConnectivityIfNeeded(force = false) {
      if (!force && isConnected) return true;
      if (pingInFlight) return false;
      pingInFlight = true;

      const url = baseUrl() + "/api/status";
      const t0 = performance.now();

      try {
        const data = await fetchJsonWithRetry(url, {
          method: "POST",
          headers: { "Content-Type": "text/plain", "Accept": "application/json" },
          body: clientId
        }, 1, 200);

        const dt = Math.round(performance.now() - t0);

        isConnected = true;
        lastGoodAt = Date.now();

        setStatus(true, `Connected (${dt}ms)`);
        metaEl.textContent = `Status OK • ${dt}ms`;
        resultsSub.textContent = `${dt}ms • status`;

        // opportunistic stats (no polling)
        tokensEl.textContent = data.tokens;
        queueEl.textContent = data.queue_len;
        usersHourEl.textContent = data.users_past_hour;

        // Update realtime vs queue mode based on returned tokens/queue
        applyRateModeFromStatus(data.tokens, data.queue_len);

        setTimeout(updateShellMeasurements, 0);
        return true;
      } catch (e) {
        isConnected = false;
        setStatus(false, "Disconnected");
        metaEl.textContent = `Ping failed: ${String(e).slice(0, 120)}`;
        resultsSub.textContent = `offline`;

        // Offer manual reconnect without any background work
        requestBtn.style.display = 'block';
        requestBtn.textContent = 'Reconnect';
        queueModeNotice.style.display = 'none';
        setInputLocked(false);

        setTimeout(updateShellMeasurements, 0);
        return false;
      } finally {
        pingInFlight = false;
      }
    }

    function maybePingOnWake() {
      const now = Date.now();
      const inactiveFor = now - lastActivityAt;
      const staleFor = now - lastGoodAt;

      const shouldPing = !isConnected || inactiveFor > inactivityMs || staleFor > 10 * 60 * 1000;
      if (shouldPing) pingConnectivityIfNeeded(true);
    }

    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') maybePingOnWake();
    });

    window.addEventListener('offline', () => {
      isConnected = false;
      setStatus(false, "Offline");
      resultsSub.textContent = "offline";
    });

    window.addEventListener('online', () => {
      pingConnectivityIfNeeded(true);
    });

    ['pointerdown','keydown','touchstart','focus'].forEach(evt => {
      window.addEventListener(evt, markActivity, { passive: true });
    });

    pingBtn.addEventListener("click", async () => {
      await pingConnectivityIfNeeded(true);
    });

    // If API URL changes, reset connectivity and allow a fresh ping (still not polling)
    apiUrlEl.addEventListener('change', () => {
      isConnected = false;
      pingConnectivityIfNeeded(true);
    });

    // ---------------------------
    // Rate-mode UI (realtime vs queue)
    // ---------------------------
    function applyRateModeFromStatus(tokens, queueLen) {
      // Realtime enabled only when tokens available and no backlog
      const shouldEnable = (parseInt(tokens, 10) > 0) && (parseInt(queueLen, 10) === 0);

      realtimeEnabled = shouldEnable;

      if (realtimeEnabled) {
        requestBtn.style.display = 'none';
        queueModeNotice.style.display = 'none';
        setInputLocked(false);
      } else {
        requestBtn.style.display = 'block';
        requestBtn.textContent = 'Request Prediction';
        queueModeNotice.style.display = 'block';
        setInputLocked(true, "waiting in queue");
      }
    }

    // ---------------------------
    // Bars: keyed DOM + FLIP reorder + numeric interpolation
    // Mobile uses condensed card rows; Desktop uses columns.
    // ---------------------------
    const rowByLabel = new Map();
    let hasRenderedOnce = false;

    function isMobile() { return window.matchMedia('(max-width: 899px)').matches; }
    function formatPct(v) { return v.toFixed(1) + "%"; }

    function tweenNumber(el, from, to, durationMs) {
      if (!Number.isFinite(from)) from = 0;
      if (!Number.isFinite(to)) to = 0;
      const start = performance.now();
      const ease = (t) => t < 0.5 ? 2*t*t : 1 - Math.pow(-2*t + 2, 2) / 2;

      function step(now) {
        const t = Math.min(1, (now - start) / durationMs);
        const v = from + (to - from) * ease(t);
        el.textContent = formatPct(v);
        if (t < 1) requestAnimationFrame(step);
        else el.textContent = formatPct(to);
      }
      requestAnimationFrame(step);
    }

    function measurePositions() {
      const positions = new Map();
      for (const [label, obj] of rowByLabel.entries()) {
        if (obj.row.isConnected) positions.set(label, obj.row.getBoundingClientRect());
      }
      return positions;
    }

    function applyFLIP(before) {
      const after = measurePositions();
      for (const [label, beforeRect] of before.entries()) {
        const obj = rowByLabel.get(label);
        if (!obj || !obj.row.isConnected) continue;
        const afterRect = after.get(label);
        if (!afterRect) continue;

        const dx = beforeRect.left - afterRect.left;
        const dy = beforeRect.top - afterRect.top;
        if (dx || dy) {
          obj.row.style.transform = `translate(${dx}px, ${dy}px)`;
          obj.row.style.transition = 'transform 0ms';
          requestAnimationFrame(() => {
            obj.row.style.transition = `transform var(--dur-med) var(--ease-inout)`;
            obj.row.style.transform = 'translate(0, 0)';
          });
        }
      }
    }

    function ensureRow(label) {
      let obj = rowByLabel.get(label);
      if (obj && obj.row.isConnected) return obj;

      const row = document.createElement("div");
      row.className = "bar-row " + (hasRenderedOnce ? "" : "enter");

      // top line: label + pct (mobile shows as flex, desktop uses contents)
      const top = document.createElement("div");
      top.className = "bar-top";

      const labelEl = document.createElement("div");
      labelEl.className = "bar-label";
      labelEl.textContent = label;

      const pctEl = document.createElement("div");
      pctEl.className = "bar-pct";
      pctEl.textContent = "0.0%";

      top.appendChild(labelEl);
      top.appendChild(pctEl);

      const track = document.createElement("div");
      track.className = "bar-track";

      const fill = document.createElement("div");
      fill.className = "bar-fill";
      fill.style.width = "0%";
      track.appendChild(fill);

      row.appendChild(top);
      row.appendChild(track);

      obj = { row, labelEl, fillEl: fill, pctEl, lastPct: 0 };
      rowByLabel.set(label, obj);
      return obj;
    }

    function renderBars(predictions, metaText) {
      let entries = Object.entries(predictions || {}).sort((a,b) => b[1] - a[1]);

      // Keep mobile stable/readable: cap to top 6
      if (isMobile()) entries = entries.slice(0, 6);

      const hasData = entries.length > 0;
      if (placeholderEl) placeholderEl.style.display = hasData ? "none" : "block";

      const before = measurePositions();
      const nextLabels = new Set(entries.map(([k]) => k));

      for (const [label, pct] of entries) {
        const obj = ensureRow(label);
        barsEl.appendChild(obj.row);

        const w = Math.max(0, Math.min(100, Number(pct) || 0));
        obj.fillEl.style.width = w + "%";

        const from = obj.lastPct;
        obj.lastPct = w;
        tweenNumber(obj.pctEl, from, w, 520);
      }

      for (const [label, obj] of rowByLabel.entries()) {
        if (!nextLabels.has(label) && obj.row.isConnected) {
          obj.row.classList.add('exit');
          requestAnimationFrame(() => {
            obj.row.classList.add('final');
            setTimeout(() => { if (obj.row.isConnected) obj.row.remove(); }, 220);
          });
        }
      }

      if (hasRenderedOnce) applyFLIP(before);
      hasRenderedOnce = true;

      if (metaText) resultsSub.textContent = metaText;
      setTimeout(updateShellMeasurements, 0);
    }

    // ---------------------------
    // Predict
    // ---------------------------
    async function predictNow() {
      if (pendingRequest) return;

      const apiUrl = apiUrlEl.value.trim();
      const text = textEl.value.trim();

      if (!text) {
        renderBars({}, "");
        metaEl.textContent = "";
        return;
      }

      pendingRequest = true;
      requestBtn.disabled = true;

      // If in queue mode, lock edits while waiting for server response
      if (!realtimeEnabled) {
        setInputLocked(true, "waiting in queue");
        setStatus(false, "Waiting in queue...");
        requestBtn.textContent = "Processing...";
      }

      const t0 = performance.now();

      try {
        const res = await fetch(apiUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Accept": "application/json",
            "x-client-id": clientId
          },
          body: JSON.stringify({ text })
        });

        if (!res.ok) {
          // if backend says rate limited, switch to queue mode
          let errorMsg = `HTTP ${res.status}`;
          try {
            const ct = res.headers.get('content-type') || '';
            if (ct.includes('application/json')) {
              const errData = await res.json();
              if (errData?.detail) errorMsg = errData.detail;
            }
          } catch {}

          if (res.status === 429) {
            realtimeEnabled = false;
            setStatus(false, "Rate limited");
            metaEl.textContent = `Rate limit: ${errorMsg}`;
            queueModeNotice.style.display = 'block';
            requestBtn.style.display = 'block';
            requestBtn.textContent = 'Request Prediction';
            setInputLocked(true, "waiting in queue");
          } else if (res.status === 413) {
            setStatus(false, "Request too long");
            metaEl.textContent = errorMsg;
          } else {
            setStatus(false, `Error ${res.status}`);
            metaEl.textContent = errorMsg;
          }

          // Treat failures as potential connectivity issue; allow a wake ping next time
          isConnected = false;
          return;
        }

        const ct = res.headers.get('content-type') || '';
        if (!ct.includes('application/json')) {
          const txt = await res.text();
          throw new Error('non-json:' + txt.slice(0, 200));
        }

        const data = await res.json();
        const dt = Math.round(performance.now() - t0);

        // Successful predict implies connected
        isConnected = true;
        lastGoodAt = Date.now();

        setStatus(true, `Connected (${dt}ms)`);
        metaEl.textContent = `Device: ${data.device ?? "unknown"} • ${dt}ms`;
        renderBars(data.predictions || {}, `${dt}ms • ${data.device ?? "unknown"}`);

        // Optional, opportunistic status refresh AFTER a prediction only (not polling)
        // This does not trigger /predict.
        pingConnectivityIfNeeded(true);

      } catch (e) {
        setStatus(false, "Error");
        metaEl.textContent = String(e).slice(0, 200);
        isConnected = false; // next wake interaction can ping status
        console.error(e);
      } finally {
        pendingRequest = false;
        requestBtn.disabled = false;

        if (!realtimeEnabled) {
          requestBtn.textContent = "Request Prediction";
          setInputLocked(true, "waiting in queue");
        } else {
          requestBtn.textContent = "Request Prediction";
          setInputLocked(false);
        }
      }
    }

    const predictDebounced = makeDebounce(predictNow, () => debounceDelay);

    // Predict triggers ONLY on user input (realtime mode)
    textEl.addEventListener("input", () => {
      markActivity();
      maybePingOnWake(); // ping status only if stale/offline; never calls /predict
      if (realtimeEnabled && !pendingRequest) predictDebounced();
    });

    // In queue mode / offline reconnect, button is explicit user action
    requestBtn.addEventListener("click", async () => {
      markActivity();
      if (requestBtn.textContent === 'Reconnect') {
        await pingConnectivityIfNeeded(true);
        return;
      }
      await predictNow();
    });

    // ---------------------------
    // Examples (explicit user action)
    // ---------------------------
    function populateExamplesFor(category, data) {
      const arr = data[category] || [];
      exampleSelect.innerHTML = "";
      for (const ex of arr) {
        const o = document.createElement('option');
        o.value = ex;
        o.textContent = ex.length > 80 ? ex.slice(0, 80) + '...' : ex;
        exampleSelect.appendChild(o);
      }
    }

    async function loadExamples() {
      const url = baseUrl() + "/api/examples";
      try {
        const data = await fetchJsonWithRetry(url, {
          method: "POST",
          headers: { "Content-Type": "text/plain", "Accept": "application/json" },
          body: clientId
        }, 2, 250);

        categorySelect.innerHTML = "";
        for (const k of Object.keys(data)) {
          const opt = document.createElement('option');
          opt.value = k;
          opt.textContent = k;
          categorySelect.appendChild(opt);
        }

        if (categorySelect.options.length > 0) {
          categorySelect.selectedIndex = 0;
          populateExamplesFor(categorySelect.value, data);
        }

        examplesPanel.classList.add('visible');
        setStatus(true, "Examples loaded");
        setTimeout(updateShellMeasurements, 0);
      } catch (e) {
        setStatus(false, "Examples load failed");
        metaEl.textContent = String(e).slice(0, 200);
      }
    }

    loadExamplesBtn.addEventListener('click', async () => {
      markActivity();
      maybePingOnWake();
      await loadExamples();
    });

    categorySelect.addEventListener('change', async () => {
      markActivity();
      maybePingOnWake();
      // reload examples data once (still explicit interaction)
      await loadExamples();
    });

    exampleSelect.addEventListener('change', () => {
      markActivity();
      maybePingOnWake();
      const v = exampleSelect.value || '';
      if (v) {
        textEl.value = v;
        // This is explicit user action -> OK to run predict once.
        if (realtimeEnabled && !pendingRequest) predictDebounced();
        else predictNow();
      }
    });

    // ---------------------------
    // INIT: one-shot ping on load, then no polling.
    // ---------------------------
    setStatus(false, "Connecting...");
    pingConnectivityIfNeeded(true); // uses /api/status only
    updateShellMeasurements();
  </script>
</body>
</html>
